// Code generated by counterfeiter. DO NOT EDIT.
package ec2fakes

import (
	"sync"
	"time"

	ec2a "github.com/aws/aws-sdk-go/service/ec2"
	"github.com/shawncatz/automagical/ec2"
)

type FakeService struct {
	AttachAddressStub        func(string, string, string) error
	attachAddressMutex       sync.RWMutex
	attachAddressArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	attachAddressReturns struct {
		result1 error
	}
	attachAddressReturnsOnCall map[int]struct {
		result1 error
	}
	AttachRecordStub        func(string, string, string) error
	attachRecordMutex       sync.RWMutex
	attachRecordArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	attachRecordReturns struct {
		result1 error
	}
	attachRecordReturnsOnCall map[int]struct {
		result1 error
	}
	AttachVolumeStub        func(string, string, string) error
	attachVolumeMutex       sync.RWMutex
	attachVolumeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	attachVolumeReturns struct {
		result1 error
	}
	attachVolumeReturnsOnCall map[int]struct {
		result1 error
	}
	FindAddressStub        func(string, string, string) (*ec2a.Address, error)
	findAddressMutex       sync.RWMutex
	findAddressArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	findAddressReturns struct {
		result1 *ec2a.Address
		result2 error
	}
	findAddressReturnsOnCall map[int]struct {
		result1 *ec2a.Address
		result2 error
	}
	FindVolumeStub        func(string, string, string) (*ec2a.Volume, error)
	findVolumeMutex       sync.RWMutex
	findVolumeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	findVolumeReturns struct {
		result1 *ec2a.Volume
		result2 error
	}
	findVolumeReturnsOnCall map[int]struct {
		result1 *ec2a.Volume
		result2 error
	}
	GetInstanceStub        func(string) (*ec2a.Instance, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		arg1 string
	}
	getInstanceReturns struct {
		result1 *ec2a.Instance
		result2 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 *ec2a.Instance
		result2 error
	}
	GetInstanceZoneStub        func(string) (string, error)
	getInstanceZoneMutex       sync.RWMutex
	getInstanceZoneArgsForCall []struct {
		arg1 string
	}
	getInstanceZoneReturns struct {
		result1 string
		result2 error
	}
	getInstanceZoneReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetTagsStub        func([]*ec2a.Tag) map[string]string
	getTagsMutex       sync.RWMutex
	getTagsArgsForCall []struct {
		arg1 []*ec2a.Tag
	}
	getTagsReturns struct {
		result1 map[string]string
	}
	getTagsReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	WaitStub        func(string, time.Duration, time.Duration) (*ec2a.Instance, map[string]string, error)
	waitMutex       sync.RWMutex
	waitArgsForCall []struct {
		arg1 string
		arg2 time.Duration
		arg3 time.Duration
	}
	waitReturns struct {
		result1 *ec2a.Instance
		result2 map[string]string
		result3 error
	}
	waitReturnsOnCall map[int]struct {
		result1 *ec2a.Instance
		result2 map[string]string
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeService) AttachAddress(arg1 string, arg2 string, arg3 string) error {
	fake.attachAddressMutex.Lock()
	ret, specificReturn := fake.attachAddressReturnsOnCall[len(fake.attachAddressArgsForCall)]
	fake.attachAddressArgsForCall = append(fake.attachAddressArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("AttachAddress", []interface{}{arg1, arg2, arg3})
	fake.attachAddressMutex.Unlock()
	if fake.AttachAddressStub != nil {
		return fake.AttachAddressStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachAddressReturns
	return fakeReturns.result1
}

func (fake *FakeService) AttachAddressCallCount() int {
	fake.attachAddressMutex.RLock()
	defer fake.attachAddressMutex.RUnlock()
	return len(fake.attachAddressArgsForCall)
}

func (fake *FakeService) AttachAddressCalls(stub func(string, string, string) error) {
	fake.attachAddressMutex.Lock()
	defer fake.attachAddressMutex.Unlock()
	fake.AttachAddressStub = stub
}

func (fake *FakeService) AttachAddressArgsForCall(i int) (string, string, string) {
	fake.attachAddressMutex.RLock()
	defer fake.attachAddressMutex.RUnlock()
	argsForCall := fake.attachAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) AttachAddressReturns(result1 error) {
	fake.attachAddressMutex.Lock()
	defer fake.attachAddressMutex.Unlock()
	fake.AttachAddressStub = nil
	fake.attachAddressReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) AttachAddressReturnsOnCall(i int, result1 error) {
	fake.attachAddressMutex.Lock()
	defer fake.attachAddressMutex.Unlock()
	fake.AttachAddressStub = nil
	if fake.attachAddressReturnsOnCall == nil {
		fake.attachAddressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachAddressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) AttachRecord(arg1 string, arg2 string, arg3 string) error {
	fake.attachRecordMutex.Lock()
	ret, specificReturn := fake.attachRecordReturnsOnCall[len(fake.attachRecordArgsForCall)]
	fake.attachRecordArgsForCall = append(fake.attachRecordArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("AttachRecord", []interface{}{arg1, arg2, arg3})
	fake.attachRecordMutex.Unlock()
	if fake.AttachRecordStub != nil {
		return fake.AttachRecordStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachRecordReturns
	return fakeReturns.result1
}

func (fake *FakeService) AttachRecordCallCount() int {
	fake.attachRecordMutex.RLock()
	defer fake.attachRecordMutex.RUnlock()
	return len(fake.attachRecordArgsForCall)
}

func (fake *FakeService) AttachRecordCalls(stub func(string, string, string) error) {
	fake.attachRecordMutex.Lock()
	defer fake.attachRecordMutex.Unlock()
	fake.AttachRecordStub = stub
}

func (fake *FakeService) AttachRecordArgsForCall(i int) (string, string, string) {
	fake.attachRecordMutex.RLock()
	defer fake.attachRecordMutex.RUnlock()
	argsForCall := fake.attachRecordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) AttachRecordReturns(result1 error) {
	fake.attachRecordMutex.Lock()
	defer fake.attachRecordMutex.Unlock()
	fake.AttachRecordStub = nil
	fake.attachRecordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) AttachRecordReturnsOnCall(i int, result1 error) {
	fake.attachRecordMutex.Lock()
	defer fake.attachRecordMutex.Unlock()
	fake.AttachRecordStub = nil
	if fake.attachRecordReturnsOnCall == nil {
		fake.attachRecordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachRecordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) AttachVolume(arg1 string, arg2 string, arg3 string) error {
	fake.attachVolumeMutex.Lock()
	ret, specificReturn := fake.attachVolumeReturnsOnCall[len(fake.attachVolumeArgsForCall)]
	fake.attachVolumeArgsForCall = append(fake.attachVolumeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("AttachVolume", []interface{}{arg1, arg2, arg3})
	fake.attachVolumeMutex.Unlock()
	if fake.AttachVolumeStub != nil {
		return fake.AttachVolumeStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.attachVolumeReturns
	return fakeReturns.result1
}

func (fake *FakeService) AttachVolumeCallCount() int {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	return len(fake.attachVolumeArgsForCall)
}

func (fake *FakeService) AttachVolumeCalls(stub func(string, string, string) error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = stub
}

func (fake *FakeService) AttachVolumeArgsForCall(i int) (string, string, string) {
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	argsForCall := fake.attachVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) AttachVolumeReturns(result1 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	fake.attachVolumeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) AttachVolumeReturnsOnCall(i int, result1 error) {
	fake.attachVolumeMutex.Lock()
	defer fake.attachVolumeMutex.Unlock()
	fake.AttachVolumeStub = nil
	if fake.attachVolumeReturnsOnCall == nil {
		fake.attachVolumeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachVolumeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) FindAddress(arg1 string, arg2 string, arg3 string) (*ec2a.Address, error) {
	fake.findAddressMutex.Lock()
	ret, specificReturn := fake.findAddressReturnsOnCall[len(fake.findAddressArgsForCall)]
	fake.findAddressArgsForCall = append(fake.findAddressArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("FindAddress", []interface{}{arg1, arg2, arg3})
	fake.findAddressMutex.Unlock()
	if fake.FindAddressStub != nil {
		return fake.FindAddressStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findAddressReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) FindAddressCallCount() int {
	fake.findAddressMutex.RLock()
	defer fake.findAddressMutex.RUnlock()
	return len(fake.findAddressArgsForCall)
}

func (fake *FakeService) FindAddressCalls(stub func(string, string, string) (*ec2a.Address, error)) {
	fake.findAddressMutex.Lock()
	defer fake.findAddressMutex.Unlock()
	fake.FindAddressStub = stub
}

func (fake *FakeService) FindAddressArgsForCall(i int) (string, string, string) {
	fake.findAddressMutex.RLock()
	defer fake.findAddressMutex.RUnlock()
	argsForCall := fake.findAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) FindAddressReturns(result1 *ec2a.Address, result2 error) {
	fake.findAddressMutex.Lock()
	defer fake.findAddressMutex.Unlock()
	fake.FindAddressStub = nil
	fake.findAddressReturns = struct {
		result1 *ec2a.Address
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindAddressReturnsOnCall(i int, result1 *ec2a.Address, result2 error) {
	fake.findAddressMutex.Lock()
	defer fake.findAddressMutex.Unlock()
	fake.FindAddressStub = nil
	if fake.findAddressReturnsOnCall == nil {
		fake.findAddressReturnsOnCall = make(map[int]struct {
			result1 *ec2a.Address
			result2 error
		})
	}
	fake.findAddressReturnsOnCall[i] = struct {
		result1 *ec2a.Address
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindVolume(arg1 string, arg2 string, arg3 string) (*ec2a.Volume, error) {
	fake.findVolumeMutex.Lock()
	ret, specificReturn := fake.findVolumeReturnsOnCall[len(fake.findVolumeArgsForCall)]
	fake.findVolumeArgsForCall = append(fake.findVolumeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("FindVolume", []interface{}{arg1, arg2, arg3})
	fake.findVolumeMutex.Unlock()
	if fake.FindVolumeStub != nil {
		return fake.FindVolumeStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findVolumeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) FindVolumeCallCount() int {
	fake.findVolumeMutex.RLock()
	defer fake.findVolumeMutex.RUnlock()
	return len(fake.findVolumeArgsForCall)
}

func (fake *FakeService) FindVolumeCalls(stub func(string, string, string) (*ec2a.Volume, error)) {
	fake.findVolumeMutex.Lock()
	defer fake.findVolumeMutex.Unlock()
	fake.FindVolumeStub = stub
}

func (fake *FakeService) FindVolumeArgsForCall(i int) (string, string, string) {
	fake.findVolumeMutex.RLock()
	defer fake.findVolumeMutex.RUnlock()
	argsForCall := fake.findVolumeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) FindVolumeReturns(result1 *ec2a.Volume, result2 error) {
	fake.findVolumeMutex.Lock()
	defer fake.findVolumeMutex.Unlock()
	fake.FindVolumeStub = nil
	fake.findVolumeReturns = struct {
		result1 *ec2a.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindVolumeReturnsOnCall(i int, result1 *ec2a.Volume, result2 error) {
	fake.findVolumeMutex.Lock()
	defer fake.findVolumeMutex.Unlock()
	fake.FindVolumeStub = nil
	if fake.findVolumeReturnsOnCall == nil {
		fake.findVolumeReturnsOnCall = make(map[int]struct {
			result1 *ec2a.Volume
			result2 error
		})
	}
	fake.findVolumeReturnsOnCall[i] = struct {
		result1 *ec2a.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetInstance(arg1 string) (*ec2a.Instance, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetInstance", []interface{}{arg1})
	fake.getInstanceMutex.Unlock()
	if fake.GetInstanceStub != nil {
		return fake.GetInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeService) GetInstanceCalls(stub func(string) (*ec2a.Instance, error)) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = stub
}

func (fake *FakeService) GetInstanceArgsForCall(i int) string {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	argsForCall := fake.getInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeService) GetInstanceReturns(result1 *ec2a.Instance, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 *ec2a.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetInstanceReturnsOnCall(i int, result1 *ec2a.Instance, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 *ec2a.Instance
			result2 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 *ec2a.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetInstanceZone(arg1 string) (string, error) {
	fake.getInstanceZoneMutex.Lock()
	ret, specificReturn := fake.getInstanceZoneReturnsOnCall[len(fake.getInstanceZoneArgsForCall)]
	fake.getInstanceZoneArgsForCall = append(fake.getInstanceZoneArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetInstanceZone", []interface{}{arg1})
	fake.getInstanceZoneMutex.Unlock()
	if fake.GetInstanceZoneStub != nil {
		return fake.GetInstanceZoneStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInstanceZoneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) GetInstanceZoneCallCount() int {
	fake.getInstanceZoneMutex.RLock()
	defer fake.getInstanceZoneMutex.RUnlock()
	return len(fake.getInstanceZoneArgsForCall)
}

func (fake *FakeService) GetInstanceZoneCalls(stub func(string) (string, error)) {
	fake.getInstanceZoneMutex.Lock()
	defer fake.getInstanceZoneMutex.Unlock()
	fake.GetInstanceZoneStub = stub
}

func (fake *FakeService) GetInstanceZoneArgsForCall(i int) string {
	fake.getInstanceZoneMutex.RLock()
	defer fake.getInstanceZoneMutex.RUnlock()
	argsForCall := fake.getInstanceZoneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeService) GetInstanceZoneReturns(result1 string, result2 error) {
	fake.getInstanceZoneMutex.Lock()
	defer fake.getInstanceZoneMutex.Unlock()
	fake.GetInstanceZoneStub = nil
	fake.getInstanceZoneReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetInstanceZoneReturnsOnCall(i int, result1 string, result2 error) {
	fake.getInstanceZoneMutex.Lock()
	defer fake.getInstanceZoneMutex.Unlock()
	fake.GetInstanceZoneStub = nil
	if fake.getInstanceZoneReturnsOnCall == nil {
		fake.getInstanceZoneReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getInstanceZoneReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetTags(arg1 []*ec2a.Tag) map[string]string {
	var arg1Copy []*ec2a.Tag
	if arg1 != nil {
		arg1Copy = make([]*ec2a.Tag, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getTagsMutex.Lock()
	ret, specificReturn := fake.getTagsReturnsOnCall[len(fake.getTagsArgsForCall)]
	fake.getTagsArgsForCall = append(fake.getTagsArgsForCall, struct {
		arg1 []*ec2a.Tag
	}{arg1Copy})
	fake.recordInvocation("GetTags", []interface{}{arg1Copy})
	fake.getTagsMutex.Unlock()
	if fake.GetTagsStub != nil {
		return fake.GetTagsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getTagsReturns
	return fakeReturns.result1
}

func (fake *FakeService) GetTagsCallCount() int {
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	return len(fake.getTagsArgsForCall)
}

func (fake *FakeService) GetTagsCalls(stub func([]*ec2a.Tag) map[string]string) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = stub
}

func (fake *FakeService) GetTagsArgsForCall(i int) []*ec2a.Tag {
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	argsForCall := fake.getTagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeService) GetTagsReturns(result1 map[string]string) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	fake.getTagsReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeService) GetTagsReturnsOnCall(i int, result1 map[string]string) {
	fake.getTagsMutex.Lock()
	defer fake.getTagsMutex.Unlock()
	fake.GetTagsStub = nil
	if fake.getTagsReturnsOnCall == nil {
		fake.getTagsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.getTagsReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeService) Wait(arg1 string, arg2 time.Duration, arg3 time.Duration) (*ec2a.Instance, map[string]string, error) {
	fake.waitMutex.Lock()
	ret, specificReturn := fake.waitReturnsOnCall[len(fake.waitArgsForCall)]
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct {
		arg1 string
		arg2 time.Duration
		arg3 time.Duration
	}{arg1, arg2, arg3})
	fake.recordInvocation("Wait", []interface{}{arg1, arg2, arg3})
	fake.waitMutex.Unlock()
	if fake.WaitStub != nil {
		return fake.WaitStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.waitReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeService) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeService) WaitCalls(stub func(string, time.Duration, time.Duration) (*ec2a.Instance, map[string]string, error)) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = stub
}

func (fake *FakeService) WaitArgsForCall(i int) (string, time.Duration, time.Duration) {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	argsForCall := fake.waitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) WaitReturns(result1 *ec2a.Instance, result2 map[string]string, result3 error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 *ec2a.Instance
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) WaitReturnsOnCall(i int, result1 *ec2a.Instance, result2 map[string]string, result3 error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = nil
	if fake.waitReturnsOnCall == nil {
		fake.waitReturnsOnCall = make(map[int]struct {
			result1 *ec2a.Instance
			result2 map[string]string
			result3 error
		})
	}
	fake.waitReturnsOnCall[i] = struct {
		result1 *ec2a.Instance
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachAddressMutex.RLock()
	defer fake.attachAddressMutex.RUnlock()
	fake.attachRecordMutex.RLock()
	defer fake.attachRecordMutex.RUnlock()
	fake.attachVolumeMutex.RLock()
	defer fake.attachVolumeMutex.RUnlock()
	fake.findAddressMutex.RLock()
	defer fake.findAddressMutex.RUnlock()
	fake.findVolumeMutex.RLock()
	defer fake.findVolumeMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.getInstanceZoneMutex.RLock()
	defer fake.getInstanceZoneMutex.RUnlock()
	fake.getTagsMutex.RLock()
	defer fake.getTagsMutex.RUnlock()
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ec2.Service = new(FakeService)
